From Coq Require Import Lists.List. Import ListNotations.
From Coq Require Import Strings.String.

(* ------------ ------------ ------------
   ------------ ------------ ------------
   ----------- Abstract Syntax -----------
   ------------ ------------ ------------
   ------------ ------------ ------------ *)
Inductive heap_loc := hloc_str : string -> heap_loc.
Inductive code_loc := cloc_str : string -> code_loc.
Inductive heap_location :=
  hloc : heap_loc -> nat -> heap_location.
Inductive code_location :=
  cloc : code_loc -> nat -> code_location.
Inductive location : Type :=
  | h_loc : heap_location -> location
  | c_loc : code_location -> location.
Inductive register : Type :=
  | nat_reg : nat -> register
  | ip
  | sp.
Inductive word : Type :=
  | loc_w : location -> word
  | int_w : nat -> word
  | ns.
Inductive operand : Type :=
  | reg_o : register -> operand
  | wd_o : word -> operand.
Inductive instr : Type :=
  | add : register -> operand -> instr
  | mkstk : register -> instr
  | salloc : nat -> instr
  | sfree : nat -> instr
  | malloc : register -> nat -> instr
  | mov : register -> operand -> instr
  | load : register -> register -> nat -> instr
  | store : register -> nat -> operand -> instr
  | push : operand -> instr
  | pop : register -> instr
  | call : operand -> instr
  | jmp : operand -> instr
  | ret
  | halt
  | ns_ins.
Inductive stack_heap_val : Type :=
  | stack : list word -> stack_heap_val
  | no_stacks.
Inductive tuple_heap_val : Type :=
  | tuple : list word -> tuple_heap_val.
Definition heap_val := (stack_heap_val + tuple_heap_val)%type.
(* Compound Lists *)
Inductive instr_seq : Type :=
  | ins_seq : list instr -> instr_seq.
Definition reg_file : Type := list (register * word).
Definition stack_heap : Type := heap_loc -> stack_heap_val.
Definition tuple_heap : Type := heap_loc -> tuple_heap_val.
Definition heap : Type := (stack_heap * tuple_heap).
Definition program : Type := code_loc -> instr_seq.

(* Coercions *)
Coercion hloc_str : string >-> heap_loc.
Coercion cloc_str : string >-> code_loc.
Coercion nat_reg : nat >-> register.
Coercion h_loc : heap_location >-> location.
Coercion c_loc : code_location >-> location.
Coercion loc_w : location >-> word.
Coercion int_w : nat >-> word.
Coercion wd_o : word >-> operand.
(* ------------ ------------ ------------
   ------------ ------------ ------------
   ------------- Interpreter -------------
   ------------ ------------ ------------
   ------------ ------------ ------------ *)

(* --------------------------------------------
   initialization and update functions for maps
         (register and heap as functions)
   -------------------------------------------- *)
Definition reg_eqb a b :=
  match a,b with
  | nat_reg n, nat_reg n' => (Nat.eqb n n')
  | ip, ip => true
  | sp, sp => true
  | _,_ => false
  end.
(* register file is always an ordered list *)
Fixpoint reg_update (rf : reg_file) (x : register) (v : word) :=
  match x,rf with
  | _,nil => (x,v) :: nil
  | ip, (ip,w) :: rf' => (ip,v) :: rf'
  | sp, (sp,w) :: rf' => (sp,v) :: rf'
  | ip, (sp,w) :: rf' => (ip,v) :: rf
  | ip, ((nat_reg _),w) :: rf' => (ip,v) :: rf
  | sp, ((nat_reg _),w) :: rf' => (sp,v) :: rf
  | nat_reg n, ((nat_reg n'),w) :: rf' =>
    if Nat.eqb n n' then (x,v) :: rf'
    else (if Nat.ltb n n' then (x,v) :: rf
      else ((nat_reg n'),w) :: (reg_update rf' x v))
  | _, (r,w) :: rf' => (r,w) :: (reg_update rf' x v)
  end.
Fixpoint reg_app (rf:reg_file) r :=
  match rf with
  | cons (x,v) rf' => if reg_eqb x r then v else reg_app rf' r
  | nil => ns
  end.
Notation "x '!->r' v ';' m" := (reg_update m x v)
  (at level 100, v at next level, right associativity).
Definition h_eqb a b :=
  match a,b with
  | hloc_str a', hloc_str b' => eqb a' b'
  end.
Definition sh_empty : stack_heap := fun _ => no_stacks.
Definition th_empty : tuple_heap := fun _ => tuple nil.
Definition h_empty : heap := (sh_empty, th_empty).
Definition sh_update (sh:stack_heap) (x:heap_loc)
  (v:stack_heap_val) :=
  (fun x' => if h_eqb x x' then v else sh x').
Definition th_update (th:tuple_heap) (x:heap_loc)
  (v:tuple_heap_val) :=
  (fun x' => if h_eqb x x' then v else th x').
Definition h_update (h : heap) (x : heap_loc) (v : heap_val) :=
  match v, h with
  | inl (stack lst), (s_h,t_h) =>
    (sh_update s_h x (stack lst),t_h)
  | inr (tuple lst), (s_h,t_h) =>
    (s_h,th_update t_h x (tuple lst))
  (* undefined below *)
  | inl no_stacks, (s_h,t_h) => (s_h,t_h)
  end.
Notation "x '!->s' v ';' m" := (sh_update m x v)
  (at level 100, v at next level, right associativity).
Notation "x '!->t' v ';' m" := (th_update m x v)
  (at level 100, v at next level, right associativity).
Notation "x '!->h' v ';' m" := (h_update m x v)
  (at level 100, v at next level, right associativity).
Definition c_eqb a b :=
  match a,b with
  | cloc_str a', cloc_str b' => eqb a' b'
  end.
Definition c_update (m : program) (x : code_loc) (v : instr_seq) :=
  fun x' => if c_eqb x x' then v else m x'.
(* Fixpoint (*code_fetch*) (c: program) (lab: code_loc) : instr_seq :=
  match c with
  | cons (x,v) c' => if c_eqb x lab then v else (*code_fetch*) c' lab
  | nil => empty_seq
  end.
*)
Notation "x '!->c' v ';' m" := (c_update m x v)
  (at level 100, v at next level, right associativity).

(* --------------------------------------------
                  Other helpers
   -------------------------------------------- *)
(* change number of increments in a location label *)
Definition next_cloc cl :=
  match cl with cloc loc n => cloc loc (S n) end.
Definition next_hloc (hl:heap_location) : heap_location :=
  match hl with hloc loc n => hloc loc (S n) end.
Fixpoint incr_cloc n (cl:code_location) : code_location :=
  match n with
  | 0 => cl
  | S n' => incr_cloc n' (next_cloc cl)
  end.
Fixpoint incr_hloc n (hl:heap_location) : heap_location :=
  match n with
  | 0 => hl
  | S n' => incr_hloc n' (next_hloc hl)
  end.

(* add n nonsenses to a list of words (for stacks) *)
Fixpoint n_cons {A:Type} n v (lst:list A) :=
  match n with
  | 0 => lst
  | S n' => n_cons n' v (cons v lst)
  end.

Fixpoint cdr_nth {A: Type} (n: nat) (lst: list A) :=
  match n, lst with
  | 0, lst' => lst'
  | S n', nil => nil
  | S n', cons x lst' => cdr_nth n' lst'
  end.
Fixpoint update_nth {A: Type} (n:nat) (lst:list A) (v:A) :=
  match n, lst with
  | 0, cons x lst' => cons v lst'
  | _, nil => nil
  | S n', cons x lst' => update_nth n' lst' v
  end.
(* --------------------------------------------
    Section for the cursive H hat of paper 
   -------------------------------------------- *)
(* returns instruction at given location *)
Definition fetch_instr_h (cl : code_location) (p : program) 
  (otherwise:instr) : instr := match cl with cloc cloc' n =>
  match p cloc' with ins_seq lst =>
  nth n lst otherwise
  end end.
Definition fetch_instr cl p := fetch_instr_h cl p ns_ins.
(* --------------------------------------------
          Section for R hat of paper
   -------------------------------------------- *)
(* returns word if given word,
   returns word in register if given register *)
Definition operand_value o (r_file:reg_file) :=
  match o with
  | reg_o r => reg_app r_file r
  | wd_o w => w
  end.
(* --------------------------------------------
          Section for H hat of paper
   -------------------------------------------- *)
(* returns word at given heap memory address *)
Definition heap_app (h: heap) (loc:heap_loc) :=
  match h with (s_h,t_h) =>
    match s_h loc with
    | stack lst => inl (stack lst)
    | no_stacks => inr (t_h loc)
    end
  end.
Definition fetch_heap (loc:heap_loc) (i:nat) (h:heap) :=
  match h with (s_h,t_h) =>
    match s_h loc with
    | stack lst => nth ((List.length lst)-i) lst ns
    | no_stacks => 
      match t_h loc with tuple lst => nth i lst ns end
    end
  end.
(* --------------------------------------------
                      Interpreter
   -------------------------------------------- *)
Inductive step (P:program) : (heap * reg_file) ->
(heap * reg_file) -> Prop :=
  | S_add : forall (H:heap) (R:reg_file) (l:code_location)
    (reg:register) (o:operand) (w1 w2: nat),
    reg_app R ip = l -> fetch_instr l P = add reg o
    -> reg_app R reg = int_w w1 -> operand_value o R = int_w w2 ->
    step P (H,R)
      (H, ip !->r next_cloc l; reg !->r w1+w2 ; R)
  | S_mkstk : forall (H:heap) (R:reg_file) (l:code_location)
    (reg:register) (L:heap_loc),
    reg_app R ip = l -> fetch_instr l P = mkstk reg
    -> heap_app H L = inr (tuple nil) ->
    step P (H,R)
      (L !->h inl (stack nil) ; H,
      ip !->r next_cloc l; reg !->r hloc L 0; R)
  | S_salloc : forall (H:heap) (R:reg_file) (l:code_location)
              (n j:nat) (lsp:heap_loc) (lst:list word),
    reg_app R ip = l -> fetch_instr l P = salloc n
    -> reg_app R sp = hloc lsp j -> heap_app H lsp = inl (stack lst)
    -> List.length lst = j ->
    step P (H,R)
      (lsp !->h inl (stack (n_cons n ns lst)); H ,
      ip !->r next_cloc l; sp !->r  hloc lsp (j+n); R)
  | S_push : forall (H:heap) (R:reg_file) (l:code_location)
           (o:operand) (j:nat) (lsp:heap_loc) (lst:list word),
    reg_app R ip = l -> fetch_instr l P = push o
    -> reg_app R sp = hloc lsp j -> heap_app H lsp = inl (stack lst)
    -> List.length lst = j ->
    step P (H,R)
      (lsp !->h inl (stack (cons (operand_value o R) lst)); H ,
      ip !->r next_cloc l; sp !->r hloc lsp (1+j); R)
  | S_sfree : forall (H:heap) (R:reg_file) (l:code_location)
            (j n:nat) (reg:register) (lsp:heap_loc) (lst:list word),
    reg_app R ip = l -> fetch_instr l P = sfree n
    -> reg_app R reg = hloc lsp j -> heap_app H lsp = inl (stack lst)
    -> j >= n -> List.length lst = j ->
    step P (H,R)
      (lsp !->h inl (stack (cdr_nth n lst)); H,
      ip !->r next_cloc l; sp !->r  hloc lsp (j-n); R)
  | S_pop : forall (H:heap) (R:reg_file) (l:code_location)
          (j:nat) (reg:register) (lsp:heap_loc) (lst:list word),
    reg_app R ip = l -> fetch_instr l P = pop reg
    -> reg_app R sp = hloc lsp j -> heap_app H lsp = inl (stack lst)
    -> j > 0 -> List.length lst = j ->
    step P (H,R)
      (lsp !->h inl (stack (cdr_nth 1 lst)); H,
      ip !->r next_cloc l; reg !->r (List.hd ns lst);
      sp !->r  hloc lsp (j-1); R)
  | S_malloc : forall (H:heap) (R:reg_file) (l:code_location)
    (i d:nat) (L:heap_loc),
    reg_app R ip = l -> fetch_instr l P = malloc d i
    -> heap_app H L = inr (tuple nil) ->
    step P (H,R)
      (L !->h inr (tuple (n_cons i ns nil)) ; H,
      ip !->r next_cloc l ; d !->r hloc L 0 ;R)
  | S_mov : forall (H:heap) (R:reg_file) (l:code_location)
    (d:nat) (o:operand),
    reg_app R ip = l -> fetch_instr l P = mov d o ->
    step P (H,R)
      (H, ip !->r next_cloc l; d !->r (operand_value o R); R)
  | S_mov_sp : forall (H:heap) (R:reg_file) (l:code_location)
             (o:operand) (L:heap_loc) (lst:list word) (j k:nat),
    reg_app R ip = l -> fetch_instr l P = mov sp o
    -> operand_value o R = hloc L j -> heap_app H L = inl (stack lst)
    -> List.length lst = k -> j <= k ->
    step P (H,R)
      (L !->h inl (stack (cdr_nth (k-j) lst)); H,
      ip !->r next_cloc l; sp !->r hloc L j ; R)
  | S_load : forall (H:heap) (R:reg_file) (l:code_location)
    (L:heap_loc) (d s j:nat),
    reg_app R ip = l -> fetch_instr l P = load d s j
    -> reg_app R s = hloc L 0 ->
    step P (H,R)
      (H, ip !->r next_cloc l; d !->r fetch_heap L j H ; R)
  | S_store : forall (H:heap) (R:reg_file) (l:code_location)
    (L:heap_loc) (d j:nat) (o:operand) (lst:list word),
    reg_app R ip = l -> fetch_instr l P = store d j o
    -> reg_app R d = hloc L 0 -> heap_app H L = inr (tuple lst) -> j < List.length lst ->
    step P (H,R)
      (L !->h inr (tuple (update_nth j lst (operand_value o R))); H,
      ip !->r next_cloc l; R)
  | S_call : forall (H:heap) (R:reg_file) (l l':code_location)
    (lsp:heap_loc) (j:nat) (o:operand) (lst:list word),
    reg_app R ip = l -> fetch_instr l P = call o
    -> reg_app R sp = hloc lsp j -> heap_app H lsp = inl (stack lst)
    -> List.length lst = j -> operand_value o R = l' ->
    step P (H,R)
      (lsp !->h inl (stack (cons (loc_w(next_cloc l)) lst)) ; H,
      ip !->r l' ; R)
  | S_jmp : forall (H:heap) (R:reg_file) (l l':code_location)
    (o:operand),
    reg_app R ip = l -> fetch_instr l P = jmp o
    -> operand_value o R = l' ->
    step P (H,R) (H, ip !->r l' ; R)
  | S_ret : forall (H:heap) (R:reg_file) (l l':code_location)
    (lst:list word) (j:nat) (lsp:heap_loc),
    reg_app R ip = l -> fetch_instr l P = ret
    -> reg_app R sp = hloc lsp j ->
    heap_app H lsp = inl (stack (cons (loc_w l') lst))
    -> List.length lst = j-1 ->
    step P (H,R)
      (lsp !->h inl (stack lst) ; H, ip !->r l' ; R)
  | S_halt : forall (H:heap) (R:reg_file) (l:code_location),
    reg_app R ip = l -> fetch_instr l P = halt ->
    step P (H,R) (H,R).

(* Some properties and lemmas to be used later 
Lemma reg_eqb_refl : forall a, reg_eqb a a = true.
Proof with simpl;try reflexivity;auto.
  intros. unfold reg_eqb. induction a... induction n...
Qed.
Lemma leb_remov_SS : forall a b,
  Nat.leb (S a) (S b) = Nat.leb a b.
Proof with try reflexivity.
intros a. induction a;intros;induction b...
Qed.
Lemma leb_ab_Sab : forall a b,
  Nat.leb a b = false -> Nat.leb (S a) b = false.
Proof with try discriminate; try reflexivity.
  intros a. induction a;intros;induction b...
  rewrite leb_remov_SS. rewrite leb_remov_SS in H. auto.
Qed.
Lemma leb_not_eqb_means_ltb : forall a b,
  Nat.leb a b = true -> Nat.eqb a b = false ->
  Nat.ltb a b = true.
Proof with try reflexivity; try discriminate.
  unfold Nat.ltb. intros a. induction a;intros;induction b...
  rewrite leb_remov_SS. auto.
Qed.
Theorem reg_file_swap : forall R a b v1 v2,
  reg_eqb a b = false ->
  (a !->r v1; b !->r v2; R) = (b !->r v2; a !->r v1; R).
Proof with auto; try reflexivity.
  intros. induction R,a,b;inversion H;try reflexivity;
    try discriminate;simpl; try destruct a0,r.
  - rewrite H1. rewrite PeanoNat.Nat.eqb_sym in H1.
    rewrite H1. destruct Nat.ltb as []eqn:?;
    rewrite PeanoNat.Nat.ltb_antisym in Heqb;
    apply eq_sym in Heqb; apply Bool.negb_sym in Heqb;
    simpl in Heqb.
    + apply leb_ab_Sab in Heqb; unfold Nat.ltb.
    rewrite Heqb. reflexivity.
    + apply leb_not_eqb_means_ltb in Heqb... 
      rewrite Heqb...
  - 

Qed.
Theorem reg_file_front_update : forall R a v1 v2,
  (a !->r v1; a !->r v2; R) = (a !->r v1; R).
Proof.
  intros. induction a,R;simpl;
    try (rewrite nat_eqb_refl);try reflexivity;
    destruct p;induction r; try reflexivity.
  - 
Qed.
(n !->r v1;
 (let (r, w) := p in
  if
   match r with
   | nat_reg n' => Nat.eqb n n'
   | _ => false
   end
  then (n, v2) :: R
  else
   if
    match r with
    | nat_reg n' => Nat.ltb n n'
    | _ => false
    end
   then (n, v2) :: p :: R
   else (r, w) :: (n !->r v2; R))) =
(let (r, w) := p in
 if
  match r with
  | nat_reg n' => Nat.eqb n n'
  | _ => false
  end
 then (n, v1) :: R
 else
  if
   match r with
   | nat_reg n' => Nat.ltb n n'
   | _ => false
   end
  then (n, v1) :: p :: R
  else (r, w) :: (n !->r v1; R))
*)

Definition normal_form_salt P H R : Prop := step P (H,R) (H,R).
Definition multi_step_salt (p:program) (h h':heap) (r r':reg_file)
 : Prop := Relation_Operators.clos_refl_trans_1n
  (heap * reg_file) (step p) (h,r) (h',r').
Definition interp p h h' r r' := 
  multi_step_salt p h h' r r' /\ normal_form_salt p h' r'.
